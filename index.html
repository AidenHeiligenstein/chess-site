<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aiden vs Local Chess Bot</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Bungee+Shade&family=Fredoka+One&display=swap');
    
    body {
      background-color: #1a1a1a;
      color: white;
      font-family: 'Fredoka One', cursive;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      margin-bottom: 20px;
      font-family: 'Bungee Shade', cursive;
      font-size: 3rem;
      color: #9d4edd;
      text-shadow: 3px 3px 0px #7209b7, 6px 6px 10px rgba(0,0,0,0.5);
      transform: rotate(-2deg);
      letter-spacing: 2px;
    }
    #board {
      width: 480px;
      height: 480px;
      border: 4px solid #9d4edd;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      margin: 20px auto;
      box-shadow: 0 0 30px rgba(157, 78, 221, 0.4);
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      user-select: none;
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      transition: all 0.2s ease;
    }
    .square:hover {
      transform: scale(1.05);
      box-shadow: inset 0 0 10px rgba(255,255,255,0.2);
    }
    .white {
      background-color: #e0aaff;
    }
    .black {
      background-color: #7209b7;
    }
    .selected {
      background-color: #ff006e !important;
      box-shadow: 0 0 15px #ff006e;
    }
    .possible-move {
      background-color: #ff006eaa !important;
    }
    #status, #moves {
      margin-top: 10px;
      font-size: 14px;
      color: #ccc;
      max-width: 600px;
      word-wrap: break-word;
    }
    #controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }
    button {
      padding: 12px 24px;
      border: none;
      background: linear-gradient(45deg, #9d4edd, #7209b7);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Fredoka One', cursive;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(157, 78, 221, 0.3);
    }
    button:hover {
      background: linear-gradient(45deg, #7209b7, #480ca8);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(157, 78, 221, 0.5);
    }
  </style>
</head>
<body>
  <h1>PURPLE CHESS</h1>
  <div id="board"></div>
  <div id="status">White to move</div>
  <div id="moves">Moves: </div>
  <div id="controls">
    <button onclick="startGame()">Start Game</button>
    <button onclick="resetGame()">Reset</button>
  </div>

  <script>
    // Simple chess game implementation
    class ChessGame {
      constructor() {
        this.board = [
          ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
          ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
          ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
        this.turn = 'white';
        this.selectedSquare = null;
        this.moveHistory = [];
        this.gameOver = false;
      }

      reset() {
        this.board = [
          ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
          ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
          ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
        this.turn = 'white';
        this.selectedSquare = null;
        this.moveHistory = [];
        this.gameOver = false;
      }

      isWhitePiece(piece) {
        return piece && piece === piece.toUpperCase();
      }

      isBlackPiece(piece) {
        return piece && piece === piece.toLowerCase();
      }

      isValidMove(fromRow, fromCol, toRow, toCol) {
        if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
        
        const piece = this.board[fromRow][fromCol];
        const targetPiece = this.board[toRow][toCol];
        
        if (!piece) return false;
        
        // Can't capture own piece
        if (targetPiece && 
            ((this.isWhitePiece(piece) && this.isWhitePiece(targetPiece)) ||
             (this.isBlackPiece(piece) && this.isBlackPiece(targetPiece)))) {
          return false;
        }

        // Basic move validation for pawns
        if (piece.toLowerCase() === 'p') {
          const direction = this.isWhitePiece(piece) ? -1 : 1;
          const startRow = this.isWhitePiece(piece) ? 6 : 1;
          
          // Forward move
          if (fromCol === toCol) {
            if (toRow === fromRow + direction && !targetPiece) return true;
            if (fromRow === startRow && toRow === fromRow + 2 * direction && !targetPiece) return true;
          }
          // Capture
          else if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && targetPiece) {
            return true;
          }
        }

        return true; // Simplified - allow most moves for other pieces
      }

      makeMove(fromRow, fromCol, toRow, toCol) {
        if (!this.isValidMove(fromRow, fromCol, toRow, toCol)) return false;
        
        const piece = this.board[fromRow][fromCol];
        const targetPiece = this.board[toRow][toCol];
        
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;
        
        const moveNotation = this.squareToNotation(fromRow, fromCol) + this.squareToNotation(toRow, toCol);
        this.moveHistory.push(moveNotation);
        
        this.turn = this.turn === 'white' ? 'black' : 'white';
        return true;
      }

      squareToNotation(row, col) {
        return String.fromCharCode(97 + col) + (8 - row);
      }

      getAllPossibleMoves(isWhite) {
        const moves = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = this.board[row][col];
            if (piece && ((isWhite && this.isWhitePiece(piece)) || (!isWhite && this.isBlackPiece(piece)))) {
              for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                  if (this.isValidMove(row, col, toRow, toCol)) {
                    moves.push({from: [row, col], to: [toRow, toCol]});
                  }
                }
              }
            }
          }
        }
        return moves;
      }

      makeBotMove() {
        const moves = this.getAllPossibleMoves(false);
        if (moves.length > 0) {
          const randomMove = moves[Math.floor(Math.random() * moves.length)];
          this.makeMove(randomMove.from[0], randomMove.from[1], randomMove.to[0], randomMove.to[1]);
        }
      }
    }

    const game = new ChessGame();
    const pieceSymbols = {
      'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };

    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = 'square ' + ((row + col) % 2 === 0 ? 'white' : 'black');
          square.dataset.row = row;
          square.dataset.col = col;
          
          const piece = game.board[row][col];
          if (piece) {
            square.textContent = pieceSymbols[piece] || piece;
          }
          
          square.addEventListener('click', handleSquareClick);
          boardEl.appendChild(square);
        }
      }
    }

    function handleSquareClick(e) {
      if (game.gameOver || game.turn !== 'white') return;
      
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      
      // Clear previous selection
      document.querySelectorAll('.square').forEach(sq => {
        sq.classList.remove('selected', 'possible-move');
      });
      
      if (game.selectedSquare) {
        const [fromRow, fromCol] = game.selectedSquare;
        
        if (row === fromRow && col === fromCol) {
          // Deselect
          game.selectedSquare = null;
          return;
        }
        
        // Try to make move
        if (game.makeMove(fromRow, fromCol, row, col)) {
          game.selectedSquare = null;
          renderBoard();
          updateStatus();
          
          // Bot move after delay
          setTimeout(() => {
            if (game.turn === 'black' && !game.gameOver) {
              game.makeBotMove();
              renderBoard();
              updateStatus();
            }
          }, 500);
        } else {
          game.selectedSquare = null;
        }
      } else {
        // Select piece
        const piece = game.board[row][col];
        if (piece && game.isWhitePiece(piece)) {
          game.selectedSquare = [row, col];
          e.target.classList.add('selected');
        }
      }
    }

    function updateStatus() {
      const statusEl = document.getElementById('status');
      const movesEl = document.getElementById('moves');
      
      statusEl.textContent = (game.turn === 'white' ? 'White' : 'Black') + ' to move';
      movesEl.textContent = 'Moves: ' + game.moveHistory.join(', ');
    }

    function startGame() {
      game.reset();
      renderBoard();
      updateStatus();
    }

    function resetGame() {
      game.reset();
      renderBoard();
      updateStatus();
    }

    // Initialize
    renderBoard();
    updateStatus();

    // Make functions global
    window.startGame = startGame;
    window.resetGame = resetGame;
  </script>
</body>
</html>
